<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Spiel mit Three.js und Ammo.js</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ammo.js"></script>
    <script>
        // Szene erstellen
        const scene = new THREE.Scene();

        // Kamera erstellen
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        // Renderer erstellen
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Licht hinzufügen
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 7.5);
        scene.add(light);

        // Ammo.js Physik-Welt erstellen
        let physicsWorld;
        let rigidBodies = [];
        const clock = new THREE.Clock();

        Ammo().then(function (Ammo) {
            const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
            const broadphase = new Ammo.btDbvtBroadphase();
            const solver = new Ammo.btSequentialImpulseConstraintSolver();
            physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
            physicsWorld.setGravity(new Ammo.btVector3(0, -9.81, 0));

            // Boden erstellen
            const ground = createBlock(0, -0.5, 0, 20, 1, 20, 0x808080, 0);
            addPhysics(ground, 0);

            // Blöcke erstellen
            createBlock(-2, 0.5, -2, 1, 1, 1, 0x00ff00, 1);
            createBlock(2, 0.5, -2, 1, 1, 1, 0x00ff00, 1);
            createBlock(-2, 0.5, 2, 1, 1, 1, 0x00ff00, 1);
            createBlock(2, 0.5, 2, 1, 1, 1, 0x00ff00, 1);

            // Spielerfigur erstellen
            const player = createPlayer(0, 1, 0);
            addPhysics(player, 1);

            // Event-Listener für Tastendrücke
            document.addEventListener('keydown', (event) => {
                switch(event.key) {
                    case 'w':
                        player.userData.velocity.z = -5;
                        break;
                    case 'a':
                        player.userData.velocity.x = -5;
                        break;
                    case 's':
                        player.userData.velocity.z = 5;
                        break;
                    case 'd':
                        player.userData.velocity.x = 5;
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch(event.key) {
                    case 'w':
                    case 'a':
                    case 's':
                    case 'd':
                        player.userData.velocity.set(0, 0, 0);
                        break;
                }
            });

            // Animationsfunktion
            function animate() {
                requestAnimationFrame(animate);

                const deltaTime = clock.getDelta();

                updatePhysics(deltaTime);

                renderer.render(scene, camera);
            }

            animate();
        });

        function createBlock(x, y, z, width, height, depth, color, mass) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshPhongMaterial({ color: color });
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            scene.add(block);
            return block;
        }

        function createPlayer(x, y, z) {
            const player = new THREE.Group();
            
            // Kopf
            const head = createBlock(0, 1.5, 0, 0.6, 0.6, 0.6, 0xffd700, 0);
            head.userData.isHead = true;
            player.add(head);
            
            // Körper
            const body = createBlock(0, 0.5, 0, 0.8, 1, 0.4, 0x00ff00, 0);
            player.add(body);
            
            // Arme
            player.add(createBlock(-0.75, 0.5, 0, 0.2, 1, 0.2, 0x00ff00, 0));
            player.add(createBlock(0.75, 0.5, 0, 0.2, 1, 0x00ff00, 0));
            
            // Beine
            player.add(createBlock(-0.25, -0.5, 0, 0.2, 1, 0.2, 0x0000ff, 0));
            player.add(createBlock(0.25, -0.5, 0, 0.2, 1, 0.2, 0x0000ff, 0));
            
            player.position.set(x, y, z);
            scene.add(player);

            player.userData.velocity = new THREE.Vector3(0, 0, 0);
            return player;
        }

        function addPhysics(object, mass) {
            const pos = object.position;
            const quat = object.quaternion;
            
            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

            const motionState = new Ammo.btDefaultMotionState(transform);

            const shape = new Ammo.btBoxShape(new Ammo.btVector3(object.scale.x * 0.5, object.scale.y * 0.5, object.scale.z * 0.5));
            shape.setMargin(0.05);

            const localInertia = new Ammo.btVector3(0, 0, 0);
            if (mass > 0) {
                shape.calculateLocalInertia(mass, localInertia);
            }

            const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
            const body = new Ammo.btRigidBody(rbInfo);

            if (mass > 0) {
                rigidBodies.push(object);
                object.userData.physicsBody = body;

                body.setActivationState(4);
                object.userData.velocity = new THREE.Vector3(0, 0, 0);
            }

            physicsWorld.addRigidBody(body);
        }

        function updatePhysics(deltaTime) {
            physicsWorld.stepSimulation(deltaTime, 10);

            for (let i = 0; i < rigidBodies.length; i++) {
                const objThree = rigidBodies[i];
                const objPhys = objThree.userData.physicsBody;
                const ms = objPhys.getMotionState();
                if (ms) {
                    ms.getWorldTransform(transformAux1);
                    const p = transformAux1.getOrigin();
                    const q = transformAux1.getRotation();
                    objThree.position.set(p.x(), p.y(), p.z());
                    objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
                }

                const velocity = objThree.userData.velocity;
                if (velocity) {
                    objPhys.setLinearVelocity(new Ammo.btVector3(velocity.x, velocity.y, velocity.z));
                }
            }
        }

        // Hilfsvariable für Transformationen
        const transformAux1 = new Ammo.btTransform();
    </script>
</body>
</html>